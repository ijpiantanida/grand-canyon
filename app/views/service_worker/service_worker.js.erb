const CACHE_NAME = 'pwa-concept-cache-v2';
const urlsToCache = [
  "<%= root_url %>",
  "<%= asset_url("application.js") %>",
  "<%= asset_url("application.css") %>",
  "<%= image_url("canyon_map.jpeg") %>"
];

self.addEventListener('install', (event) => {
  console.log("Service worker installing");
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => {
        return cache.addAll(urlsToCache);
      })
      .then(() => self.skipWaiting())
  );
});

self.addEventListener('activate', (event) => {
  console.log("Service worker activating");
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames
          .filter(cacheName => cacheName != CACHE_NAME)
          .map(cacheName => caches.delete(cacheName)));
    }));
});

self.addEventListener('fetch', (event) => {
  //Any html page will return the same HTML as the home, which is cached
  if (event.request.mode === 'navigate' ||
    (event.request.method === 'GET' &&
    event.request.headers.get('accept').includes('text/html'))) {
    return event.respondWith(
      caches.match("/")
        .then(response => {
          console.log(event.request.url, "was cached");
          return response;
        }).catch(error => myFetch(event.request))
    );
  }

  if (event.request.url.match(/api\/poi$/)) {
    return event.respondWith(
      myFetch(event.request)
        .then(response => caches.open(CACHE_NAME)
          .then(cache => {
            cache.put(event.request, response.clone());
            return response;
          }))
        .catch(() => caches.match(event.request.url))
    );
  }

  if (urlsToCache.find((url) => event.request.url === url)) {
    return event.respondWith(
      caches.match(event.request)
        .catch(() => myFetch(event.request))
    )
  }

  event.respondWith(myFetch(event.request));
});

function broadcastMessage(command, data) {
  const payload = Object.assign({command: command}, data);
  self.clients.matchAll().then(clients =>
    clients.forEach(client => client.postMessage(payload))
  );
}

let lastReportedOnlineStatus = true;
function myFetch(request) {
  return fetch(request)
    .then((response) => {
      if(!lastReportedOnlineStatus) {
        lastReportedOnlineStatus = true;
        broadcastMessage("networkStatus", {online: true});
      }
      return response;
    })
    .catch((error) => {
      lastReportedOnlineStatus = false;
      broadcastMessage("networkStatus", {online: false});
      throw error;
    })
}